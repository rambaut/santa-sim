#summary Documentation

= Installation =

= Invocation =

== Windows platforms ==

The simplest way to run a simulation configured in config.xml is to invoke the following command from the DOS prompt, from within the directory where your config.xml file is located:

{{{
java -jar c:\path\to\santa.jar config.xml
}}}

Replace `c:\path\to\santa.jar` with the path where you extracted the santa.jar file.

In some cases it may be necessary to configure the JVM to use more memory:

{{{
java -Xmx512M -jar c:\path\to\santa.jar config.xml
}}}

== UNIX, MacOS X, or Linux ==

Change directory to where your config.xml file is located, and invoke using:

{{{
$ java -jar /path/to/santa.jar config.xml
}}}

Replace `/path/to/santa.jar` with the path where you extracted the santa.jar file.

In some cases it may be necessary to configure the JVM to use more memory:

{{{
$ java -Xmx512M -jar /path/to/santa.jar config.xml
}}}

== Command-line options ==

You can bind values to parameters used in your config file. For example to bind the value '10000' to parameter 'generations', and '0.1' to parameter 'selection' use:

{{{
java -jar .../santa.jar -generations=10000 -selection=0.1 config.xml
}}}

= Configuration XML File =

All properties of a simulation, including definition of the initial population, fitness functions, replication and mutation operators, and sampling information, is defined a single XML file.

== Overall format ==

The overall format of a configuration file is like this:

{{{
<santa xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="santa.xsd">

    <!-- How many times should the simulation be run ?
         Optional (default = 1) -->
    <replicates>100</replicates>

    <simulation>
        <!-- Description of the genome: properties, example sequences, and features -->
        <genome>
            ...
        </genome>

        <!-- Definition of the initial population -->
        <population>
            ...
        </population>

        <!-- Description of the (default) fitness function -->
        <fitnessFunction>
            ...
        </fitnessFunction>

        <!-- Description of the (default) replicator -->
        <replicator>
            ...
        </replicator>

        <!-- Description of the (default) mutator -->
        <mutator>
            ...
        </mutator>

        <!-- Definition of a first epoch -->
        <epoch>
            <!-- A name for the epoch (used only to display simulator progress) -->
            <name>epoch 1</name>

            <!-- Duration of the epoch in number of generations -->
            <generations>1000</generations>

            <!-- Optionally, override the default fitness function, replicator, or mutator -->
            <fitnessFunction>
                 ...
            </fitnessFunction>

            <replicator>
                 ...
            </replicator>

            <mutator>
                 ...
            </mutator>
        </epoch>

        <!-- Optionally, additional epochs... -->
        <epoch>
            ...
        </epoch>

        <!-- Define when and how information must be sampled from the simulation -->
        <samplingSchedule>
            ...
        </samplingSchedule>
    </simulation>
</santa>
}}}

== Genome description: <genome> ==

The genome description specifies the length and organization of the genome in different features. A feature corresponds to an open reading frame, and specifies either a nucleotide or transcribed amino acid sequence.

The organization of the genome in features allows to later define different modes of selection that act on different parts of the genome.

In addition, a single sequence or sequence alignment may be specified in the genome definition, which may be used to seed the initial population (if configured so in the <population> definition), or to configure a purifying selection to reflect observed states (if configured so in a <purifyingFitness> definition).

An example of a genome definition:

{{{
<genome>
    <length>21</length>

    <!-- protein from a forward ORF that spans the entire genome -->
    <feature>
       <name>ABC protein</name>
       <type>aminoAcid</type>
       <coordinates>1-21</coordinates>
    </feature>

    <!-- protein from a backward ORF spanning sites 11 to 19 --> 
    <feature>    
       <name>DE protein</name>
       <type>aminoAcid</type>
       <coordinates>19-11</coordinates>
    </feature>

    <sequences>
>seq1
CCTCAGGTCACTCTTTGGCAAC
>seq2
CCTCGGGTCACTCCTTGGCGAC
    </sequences>
</genome>
}}}

=== Genome length: <length> ===

The genome length, as a number of nucleotides.

=== Genome feature: <feature> ===

A genome feature has three properties:
 * *<name>* A unique feature name.
 * *<type>* Must be 'nucleotide' or 'aminoAcid'. This is used to define if a fitness factor acts on nucleotides or amino acids. Note that for aminoAcid, the length of the feature needs to be a multiple of 3.
 * *<coordinates>* Defines how the feature is created from nucleotides in the genome. The format is a comma-separated list of fragments. Each fragment is defined by a single nucleotide site, or a range (begin-end). A range where begin is larger than end is read in the opposite direction. 

By default, a nucleotide feature _genome_ is created, which represents the entire genome.

=== Sequence or sequence alignment: <sequences> ===

One or multiple full-genome sequences may be given, either in FASTA or _plain_ format. In the plain format, sequences are separated by a new-line.

== Initial population: <population> ==

The initial population is described by a population size and a way to create its genomes. Note that currently, the population size is kept constant throughout the entire simulation.

An example of a population definition:
{{{
<population>
    <populationSize>10000</populationSize>
    <inoculum>all</inoculum>
</population>
}}}

=== Population size: <populationSize> ===

The number of individuals in the population. Simulation speed is roughly _N_ log _N_ to the population size _N_. *TODO: check this!*

=== Inoculum: <inoculum> ===

Defines how the genomes for all individuals in the initial population are initialized. The <inoculum> definition is optional and 'none' is the default value.

Possible values are:
 * *none*: initialize the genome of all individuals to a default nucleotide sequence which is poly-adenine ('AAA...')
 * *all*: initialize the genome of each individual by sampling, with replacement, from all sequences provided in the <sequences> within the <genome> description.
 * *consensus*: initialize the genome of all individuals to the consensus sequence for the sequences provided in the <sequences> within the <genome> description.
 * *random*: initialize the genome of all individuals to the same sequence, randomly  chosen from the sequences provided in the <sequences> within the <genome> description.

== Fitness function: <fitnessFunction> ==

This defines a fitness function. The fitness function is provided as one or more factors, each acting on certain genomic nucleotide or amino acid features, which are multiplied to compute the fitness for a single individual.

An empty <fitnessFunction> definition corresponds to a neutral fitness function: the fitness of all individuals is the same, regardless of their genome sequence.

Each factor applies to a selection of sites within a single genome feature.

An example of a fitness function block (with two factors):

{{{
<fitnessFunction>

    <!-- purifying fitness on all amino acids in ABC protein, except for the 4th -->    
    <purifyingFitness>
        <feature>ABC protein</feature>
        <sites>1-3,5-7</sites>
        <rank>
       	    <order>observed</order>
            <breakTies>random</breakTies>
        </rank>
        <fitness>
	    <lowFitness>0.5</lowFitness>
            <minimumFitness>0.1</minimumFitness>
        </fitness>
    </purifyingFitness>

    <!-- age dependent fitness on alleles corresponding to the entire DE protein -->    
    <ageDependentFitness>
	<feature>DE protein</feature>
	<declineRate>0.005</declineRate>
    </ageDependentFitness>

</fitnessFunction>
}}}

=== Feature and sites ===

Each factor is applied to a selection of sites in a genome feature. By default, this feature is the _genome_ feature (nucleotides of the entire genome), and the sites are all sites in the feature.

This may be overridden by:

 * *<feature>*: the name of one of the defined features in the <genome> description. If omitted, _genome_ is assumed.
 * *<sites>*: A comma separated list of single sites or site ranges within the feature. Note that if the feature is an amino acid feature, this refers to amino acid sites, while if the feature is a nucleotide feature, this refers to nucleotide sites.

=== Emperical fitness function: <empiricalFitness> ===

This fitness function defines the fitness for each state, and acts on each site individually.

All that is needed to define an empirical fitness function is a list of fitness values for each of the possible states (20 for an amino acid feature, 4 for a nucleotide feature).

An example of an empirical fitness function:

{{{
<empiricalFitness>
    <feature>ABC protein</feature>
    <sites>4</sites>

    <!-- assign fitness 1 to K, 0.85 to N, and 0.01 to all other amino acids -->
    <values>
      0.01 <!-- A -->
      0.01 <!-- C -->
      0.01 <!-- D -->
      0.01 <!-- E -->
      0.01 <!-- F-->
      0.01 <!-- G -->
      0.01 <!-- H -->
      0.01 <!-- I -->
      1    <!-- K -->
      0.01 <!-- L -->
      0.01 <!-- M -->
      0.85 <!-- N -->
      0.01 <!-- P -->
      0.01 <!-- Q -->
      0.01 <!-- R -->
      0.01 <!-- S -->
      0.01 <!-- T -->
      0.01 <!-- V -->
      0.01 <!-- W -->
      0.01 <!-- Y -->
    </values>
</empiricalFitness>
}}}

An empirical fitness function requires you to define the values:

 * <values>: A list of fitness values (4 for a nucleotide feature or 20 for an amino acid feature), separated by white-space (space or new-lines), which corresponds to the states in alphabetical order.

=== Purifying fitness function: <purifyingFitness> ===

This fitness function defines a purifying selection, which acts on each site individually.

For each site, it assigns a fitness to the different states, between 1 and 0, where '1' corresponds to the most fit state, and '0' to a lethal state. The definition is modular: you need to define a way to rank the states from most to least fit, and separately define a way to assign the fitness values to this rank. To reflect that some states are completely lethal, the ranking also defines a _probable_ set of states. 

For each site, the different possible states (4 nucleotides or 20 amino acids) are ordered according to a <rank> definition and these states are then assigned a fitness, according to a <fitness> definition.

Optionally, in a <fluctuate> block, you may define a process which, at random time points, makes another state the most fit. In this way, the purifying fitness function may be used to cause a non-stationary positive selection.

An example of a purifying fitness function block:

{{{
<purifyingFitness>
    <feature>ABC protein</feature>
    <sites>1-3,5-7</sites>
    <rank>
        <order>chemical</order>
        <breakTies>ordered</breakTies>
    </rank>
    <fitness>
	<lowFitness>0.5</lowFitness>
        <minimumFitness>0.1</minimumFitness>
    </fitness>
</purifyingFitness>
}}}

==== States ranked from most fit to most deleterious: <rank> ====

Within the rank, it is specified how the possible states at each site are ordered from most fit to most deleterious, and defines a set of _probable_ states.

 * <order>: how the states should be ordered:
   Possible values are:
   * *observed*: states are ordered by their frequency in the <sequences> alignment defined in the <genome> description, by decreasing frequency.
   * *chemical*: amino acids are ordered so that the amino acids in the set with chemical properties similar to the most frequent amino acid in the <sequences> alignment defined in the <genome> description, are ranked before the other states. The sets (in no particular order, and separated by |) are: AVIL|F|CM|G|ST|W|Y|P|DE|NQ|HKR.
   * *hydropathy*: idem but using a partition based on hydrophathy: IVLFCMAW|GTSYPH|DEKNQR.
   * *volume*: idem but using a partition based on volume: GAS|CDPNT|EVQH|MILKR|FYW
   * A custom partition of the states, which is defined by listing them separated by '|' (like the partitions defined above).
   * A custom order of _probable_ states, which is defined by listing the _probable_ states from most fit to least fit. (e.g. `QDNTP`) 

 * <breakTies>: configure whether ties should be broken randomly ('random') or should the state order be used ('ordered') when two states would be given the same rank.

 * <probableSet>: when defining <fitness> as a piece-wise linear model in terms of <lowFitness> and <minimumFitness>, only the _probable_ states are not assigned the minimum fitness.

   Unless the amount of probable states are overridden here, it is defined, for each site, based on the order used: when order is _observed_, only the states with frequency non-zero frequency are _probable_; when order is based on a partition, only those states in the set with the most frequent state are _probable_.

==== Fitness values assigned to states: <fitness> ====

Fitness values are assigned to the ranked states, either by specifying a list of fitness values (with <values>) or based on a piece wise linear model (with <lowFitness> and <minimumFitness>):

 * <values>: A decreasing list of relative fitness vlaues (4 for a nucleotide feature or 20 for an amino acid feature), all between 0 and 1, separated by white-space (space or new-lines). The most fit should be assigned a value of 1.

 * <lowFitness> and <minimumFitness>: Defines a piece wise linear model as in the figure below (*TODO*).

==== Creating a non-stationary positive selection: <fluctuate> ====

A purifying fitness function can be transformed into a non-stationary positive selection, by making, at random times, another state the most fit state (i.e. the state with fitness '1'). This process is controlled by two parameters:

 * <rate>: The rate of a Bernouilli process, which is the probability to fluctuate, per site, per generation.

 * <fitnessLimit>: Only consider states with at least this fitness to become the new fittest state (default value is 0, allowing any state to become the new fittest state).

=== Frequency dependent fitness function: <frequencyDependentFitness> ===

=== Age dependent fitness function: <ageDependentFitness> ===

=== Exposure dependent fitness function: <exposureDependentFitness> ===

