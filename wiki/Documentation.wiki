#summary Documentation

= Installation =

= Invocation =

== Windows platforms ==

The simplest way to run a simulation configured in config.xml is to
invoke the following command from the DOS prompt, from within the
directory where your config.xml file is located:

{{{
java -jar c:\path\to\santa.jar config.xml
}}}

Replace `c:\path\to\santa.jar` with the path where you extracted the santa.jar file.

In some cases it may be necessary to configure the JVM to use more memory:

{{{
java -Xmx512M -jar c:\path\to\santa.jar config.xml
}}}

== UNIX, MacOS X, or Linux ==

Change directory to where your config.xml file is located, and invoke using:

{{{
$ java -jar /path/to/santa.jar config.xml
}}}

Replace `/path/to/santa.jar` with the path where you extracted the santa.jar file.

In some cases it may be necessary to configure the JVM to use more memory:

{{{
$ java -Xmx512M -jar /path/to/santa.jar config.xml
}}}

== Command-line options ==

You can bind values to parameters used in your config file. For
example to bind the value '10000' to parameter 'generations', and
'0.1' to parameter 'selection' use:

{{{
java -jar .../santa.jar -generations=10000 -selection=0.1 config.xml
}}}

= Configuration XML File =

All properties of a simulation, including definition of the initial
population, fitness functions, replication and mutation operators, and
sampling information, is defined a single XML file.

== Overall format ==

The overall format of a configuration file is like this:

{{{
<santa xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="santa.xsd">

    <!-- How many times should the simulation be run ?
         Optional (default = 1) -->
    <replicates>100</replicates>

    <simulation>
        <!-- Description of the genome: properties, example sequences, and features -->
        <genome>
            ...
        </genome>

        <!-- Definition of the initial population -->
        <population>
            ...
        </population>

        <!-- Description of the (default) fitness function -->
        <fitnessFunction>
            ...
        </fitnessFunction>

        <!-- Description of the (default) replicator -->
        <replicator>
            ...
        </replicator>

        <!-- Description of the (default) mutator -->
        <mutator>
            ...
        </mutator>

        <!-- Definition of a first epoch -->
        <epoch>
            <!-- A name for the epoch (used only to display simulator progress) -->
            <name>epoch 1</name>

            <!-- Duration of the epoch in number of generations -->
            <generations>1000</generations>

            <!-- Optionally, override the default fitness function, replicator, or mutator -->
            <fitnessFunction>
                 ...
            </fitnessFunction>

            <replicator>
                 ...
            </replicator>

            <mutator>
                 ...
            </mutator>
        </epoch>

        <!-- Optionally, additional epochs... -->
        <epoch>
            ...
        </epoch>

        <!-- Define when and how information must be sampled from the simulation -->
        <samplingSchedule>
            ...
        </samplingSchedule>
    </simulation>
</santa>
}}}

== Genome description: <genome> ==

The genome description specifies the length and organization of the
genome in different features. A feature corresponds to an open reading
frame, and specifies either a nucleotide or transcribed amino acid
sequence.

The organization of the genome in features allows to later define
different modes of selection that act on different parts of the
genome.

In addition, a single sequence or sequence alignment may be specified
in the genome definition, which may be used to seed the initial
population (if configured so in the <population> definition), or to
configure a purifying selection to reflect observed states (if
configured so in a <purifyingFitness> definition).

An example of a genome definition:

{{{
<genome>
    <length>21</length>

    <!-- protein from a forward ORF that spans the entire genome -->
    <feature>
       <name>ABC protein</name>
       <type>aminoAcid</type>
       <coordinates>1-21</coordinates>
    </feature>

    <!-- protein from a backward ORF spanning sites 11 to 19 --> 
    <feature>    
       <name>DE protein</name>
       <type>aminoAcid</type>
       <coordinates>19-11</coordinates>
    </feature>

    <sequences>
>seq1
CCTCAGGTCACTCTTTGGCAAC
>seq2
CCTCGGGTCACTCCTTGGCGAC
    </sequences>
</genome>
}}}

=== Genome length: <length> ===

The genome length, as a number of nucleotides.

=== Genome feature: <feature> ===

A genome feature has three properties:
 * *<name>* A unique feature name.

 * *<type>* Must be 'nucleotide' or 'aminoAcid'. This is used to define if a fitness factor acts on nucleotides or amino acids. Note that for aminoAcid, the length of the feature needs to be a multiple of 3.

 * *<coordinates>* Defines how the feature is created from nucleotides in the genome. The format is a comma-separated list of fragments. Each fragment is defined by a single nucleotide site, or a range (begin-end). A range where begin is larger than end is read in the opposite direction.

By default, a nucleotide feature _genome_ is created, which represents
the entire genome.

=== Sequence or sequence alignment: <sequences> ===

One or multiple full-genome sequences may be given, either in FASTA or
_plain_ format. In the plain format, sequences are separated by a
new-line.

== Initial population: <population> ==

The initial population is described by a population size and a way to
create its genomes. Note that currently, the population size is kept
constant throughout the entire simulation.

An example of a population definition:
{{{
<population>
    <populationSize>10000</populationSize>
    <inoculum>all</inoculum>
</population>
}}}

=== Population size: <populationSize> ===

The number of individuals in the population. Simulation speed is
roughly _N_ log _N_ to the population size _N_. *TODO: check this!*

=== Inoculum: <inoculum> ===

Defines how the genomes for all individuals in the initial population
are initialized. The <inoculum> definition is optional and 'none' is
the default value.

Possible values are:

 * *none*: initialize the genome of all individuals to a default nucleotide sequence which is poly-adenine ('AAA...')

 * *all*: initialize the genome of each individual by sampling, with replacement, from all sequences provided in the <sequences> within the <genome> description.

 * *consensus*: initialize the genome of all individuals to the consensus sequence for the sequences provided in the <sequences> within the <genome> description.

 * *random*: initialize the genome of all individuals to the same sequence, randomly chosen from the sequences provided in the <sequences> within the <genome> description.

== Fitness function: <fitnessFunction> ==

This defines a fitness function. The fitness function is provided as
one or more factors, each acting on certain genomic nucleotide or
amino acid features, which are multiplied to compute the fitness for a
single individual.

An empty <fitnessFunction> definition corresponds to a neutral fitness
function: the fitness of all individuals is the same, regardless of
their genome sequence.

Each factor applies to a selection of sites within a single genome feature.

An example of a fitness function block (with two factors):

{{{
<fitnessFunction>

    <!-- purifying fitness on all amino acids in ABC protein, except for the 4th -->    
    <purifyingFitness>
        <feature>ABC protein</feature>
        <sites>1-3,5-7</sites>
        <rank>
       	    <order>observed</order>
            <breakTies>random</breakTies>
        </rank>
        <fitness>
	    <lowFitness>0.5</lowFitness>
            <minimumFitness>0.1</minimumFitness>
        </fitness>
    </purifyingFitness>

    <!-- age dependent fitness on alleles corresponding to the entire DE protein -->    
    <ageDependentFitness>
	<feature>DE protein</feature>
	<declineRate>0.005</declineRate>
    </ageDependentFitness>

</fitnessFunction>
}}}

=== Feature and sites ===

Each factor is applied to a selection of sites in a genome feature. By
default, this feature is the _genome_ feature (nucleotides of the
entire genome), and the sites are all sites in the feature.

This may be overridden by:

 * *<feature>*: the name of one of the defined features in the <genome> description. If omitted, _genome_ is assumed.

 * *<sites>*: A comma separated list of single sites or site ranges within the feature. Note that if the feature is an amino acid feature, this refers to amino acid sites, while if the feature is a nucleotide feature, this refers to nucleotide sites.

=== Emperical fitness function: <empiricalFitness> ===

This fitness function defines the fitness for each state, and acts on each site individually.

All that is needed to define an empirical fitness function is a list
of fitness values for each of the possible states (20 for an amino
acid feature, 4 for a nucleotide feature).

An example of an empirical fitness function:

{{{
<empiricalFitness>
    <feature>ABC protein</feature>
    <sites>4</sites>

    <!-- assign fitness 1 to K, 0.85 to N, and 0.01 to all other amino acids -->
    <values>
      0.01 <!-- A -->
      0.01 <!-- C -->
      0.01 <!-- D -->
      0.01 <!-- E -->
      0.01 <!-- F-->
      0.01 <!-- G -->
      0.01 <!-- H -->
      0.01 <!-- I -->
      1    <!-- K -->
      0.01 <!-- L -->
      0.01 <!-- M -->
      0.85 <!-- N -->
      0.01 <!-- P -->
      0.01 <!-- Q -->
      0.01 <!-- R -->
      0.01 <!-- S -->
      0.01 <!-- T -->
      0.01 <!-- V -->
      0.01 <!-- W -->
      0.01 <!-- Y -->
    </values>
</empiricalFitness>
}}}

To define an empirical fitness function, you need to define:

 * *<values>*: A list of fitness values (4 for a nucleotide feature or 20 for an amino acid feature), separated by white-space (space or new-lines), which corresponds to the states in alphabetical order.

=== Purifying fitness function: <purifyingFitness> ===

This fitness function defines a purifying selection, which acts on
each site individually.

For each site, it assigns a fitness to the different states, between 1
and 0, where '1' corresponds to the most fit state, and '0' to a
lethal state. The definition is modular: you need to define a way to
rank the states from most to least fit, and separately define a way to
assign the fitness values to this rank. To reflect that some states
are completely lethal, the ranking also defines a _probable_ set of
states.

For each site, the different possible states (4 nucleotides or 20
amino acids) are ordered according to a <rank> definition and these
states are then assigned a fitness, according to a <fitness>
definition.

Optionally, in a <fluctuate> block, you may define a process which, at
random time points, makes another state the most fit. In this way, the
purifying fitness function may be used to cause a non-stationary
positive selection.

An example of a purifying fitness function block:

{{{
<purifyingFitness>
    <feature>ABC protein</feature>
    <sites>1-3,5-7</sites>
    <rank>
        <order>chemical</order>
        <breakTies>ordered</breakTies>
    </rank>
    <fitness>
	<lowFitness>0.5</lowFitness>
        <minimumFitness>0.1</minimumFitness>
    </fitness>
</purifyingFitness>
}}}

==== States ranked from most fit to most deleterious: <rank> ====

Within the rank, it is specified how the possible states at each site
are ordered from most fit to most deleterious, and defines a set of
_probable_ states.

 * *<order>*: how the states should be ordered. Possible values are:
   * *observed*: states are ordered by their frequency in the <sequences> alignment defined in the <genome> description, by decreasing frequency.
   * *chemical*: amino acids are ordered so that the amino acids in the set with chemical properties similar to the most frequent amino acid in the <sequences> alignment defined in the <genome> description, are ranked before the other states. The sets (in no particular order, and separated by |) are: AVIL|F|CM|G|ST|W|Y|P|DE|NQ|HKR.
   * *hydropathy*: idem but using a partition based on hydrophathy: IVLFCMAW|GTSYPH|DEKNQR.
   * *volume*: idem but using a partition based on volume: GAS|CDPNT|EVQH|MILKR|FYW
   * A custom partition of the states, which is defined by listing them separated by '|' (like the partitions defined above).
   * A custom order of _probable_ states, which is defined by listing the _probable_ states from most fit to least fit. (e.g. `QDNTP`)

 * *<breakTies>*: configure whether ties should be broken randomly ('random') or should the state order be used ('ordered') when two states would be given the same rank.

 * *<probableSet>*: when defining <fitness> as a piece-wise linear model in terms of <lowFitness> and <minimumFitness>, only the _probable_ states are not assigned the minimum fitness.

   Unless the amount of probable states are overridden here, it is defined, for each site, based on the order used: when order is _observed_, only the states with frequency non-zero frequency are _probable_; when order is based on a partition, only those states in the set with the most frequent state are _probable_.

==== Fitness values assigned to states: <fitness> ====

Fitness values are assigned to the ranked states, either by specifying
a list of fitness values (with <values>) or based on a piece wise
linear model (with <lowFitness> and <minimumFitness>):

 * *<values>*: A decreasing list of relative fitness vlaues (4 for a nucleotide feature or 20 for an amino acid feature), all between 0 and 1, separated by white-space (space or new-lines). The most fit should be assigned a value of 1.

 * *<lowFitness>* and *<minimumFitness>*: Defines a piece wise linear model as in the figure below (*TODO*).

==== Creating a non-stationary positive selection: <fluctuate> ====

A purifying fitness function can be transformed into a non-stationary
positive selection, by making, at random times, another state the most
fit state (i.e. the state with fitness '1'). This process is
controlled by two parameters:

 * *<rate>*: The rate of a Bernouilli process, which is the probability to fluctuate, per site, per generation.

 * *<fitnessLimit>*: Only consider states with at least this fitness to become the new fittest state (default value is 0, allowing any state to become the new fittest state).

=== Frequency dependent fitness function: <frequencyDependentFitness> ===

This fitness function (as well as the age and exposure dependent
fitness functions), considers unique _alleles_ formed by the selected
feature sites. Individuals have a same allele if they have exactly the
same nucleotide or amino acid sequence at the selected sites.

The frequency dependent fitness function assigns a fitness to an
individual based on the frequency of the allele in the population, and
assigns a lower fitness to alleles that occur more frequently, using
the formula: f = 1 - _p_ _^shape^_, where _p_ is the frequency
(between 0 and 1) of the allele in the population, and _shape_ a
parameter that controls how severe more frequent alleles are punished
in terms of fitness.

An example of a frequency dependent fitness function:

{{{
<frequencyDependentFitness>
    <feature>DE protein</feature>
    <shape>0.5</shape>
</frequencyDependentFitness>
}}}

The fitness function is controlled by a single parameter:

 * *<shape>*: a positive number indicating how severe more frequent alleles are punished: e.g. 0.5 for square root function, 1 for linear, 2 for quandratic, ...

*TODO: show figure relating prevalence to fitness for different values of the shape parameter.*

=== Age dependent fitness function: <ageDependentFitness> ===

This fitness function (as well as the frequency and exposure dependent
fitness functions), considers unique _alleles_ formed by the selected
feature sites. Individuals have a same allele if they have exactly the
same nucleotide or amino acid sequence at the selected sites.

The frequency dependent fitness function assigns a fitness to an
individual based on the age of the allele in the population (since it
last appeared), and assigns a lower fitness to alleles that have been
continuously present in the population for a longer time, using the
formula: f = _e_ _^-declineRate a^_, where _a_ is the age (in number
of generations) of the allele in the population, and _declineRate_ a
parameter that controls how severe older alleles are punished in terms
of fitness.

An example of an age dependent fitness function:

{{{
<ageDependentFitness>
    <feature>DE protein</feature>
    <declineRate>0.005</declineRate>
</ageDependentFitness>
}}}

The fitness function is controlled by a single parameter:

 * *<declineRate>*: a positive number indicating how severe older alleles are punished in terms of fitness.

*TODO: show figure relating age to fitness for different values of the declineRate parameter.*

=== Exposure dependent fitness function: <exposureDependentFitness> ===

This fitness function (as well as the frequency and age dependent
fitness functions), considers unique _alleles_ formed by the selected
feature sites. Individuals have a same allele if they have exactly the
same nucleotide or amino acid sequence at the selected sites.

The exposure dependent fitness function assigns a fitness to an
individual based on how much the allele has been exposed in the
population (since it last appeared), and assigns a lower fitness to
alleles that have been present for a longer time in a higher
prevalence in the population for a longer time, using the formula: f =
_e_ _^-penalty E^_, where _E_ is the integrated prevalence of the
allele over time since its last appearance, and _penalty_ a parameter
that controls how severe past exposure is punished in terms of
fitness.

In this way, the exposure dependent fitness function is like the age
dependent fitness function, but takes into account the prevalence
rather then the mere presence of the allele.

An example of an exposure dependent fitness function:

{{{
<exposureDependentFitness>
    <feature>DE protein</feature>
    <penalty>0.01</penalty>
</exposureDependentFitness>
}}}

The fitness function is controlled by a single parameter:

 * *<penalty>*: a positive number indicating how severe more exposed alleles are punished in terms of fitness.

*TODO: show figure relating exposure to fitness for different values of the penalty parameter.*

== The replication operator: <replicator> ==

The replicator defines how a child genome is created given one or more
parent genomes.

Two different replication operators are available. A clonal replicator
copies the genome from a single parent. A recombinant replicator
considers that occasionally a child genome is derived from two
parents, where the child genome sequence is created by copying the
genome of one or the other parent, switching between these two genomes
at random sites. In both cases, occasional mistakes during the copying
are modelled by the mutation operator <mutator>.

=== Clonal replication: <cloncalReplicator> ===

The clonal replicator simply copies the genome of a single parent. It
has no parameters that need to be defined.

An example of a clonal replicator:

{{{
<replicator>
    <cloncalReplicator />
</replicator>
}}}

=== Recombinant replication: <recombinantReplicator> ===

The recombinant replicator considers that occasionally a child genome
is derived from two parents, where the child genome sequence is
created by copying the genome of one or the other parent, switching
between these two genomes at random sites.

The operator is configured using two parameters. The first parameter
(<dualInfectionProbability>) defines the probability that
recombination takes place, and its name is based on the replication
model of HIV where recombination can only occur when a single cell was
infected simultaneously by two different virions, in this way
packaging two different genomes in a single virion. The second
parameter (<recombinationProbability>) defines the probability (per
nucleotide site) that recombination occurs, switching between these
two template genomes.

An example of a recombinant replicator:

{{{
<replicator>
    <recombinantReplicator>
        <dualInfectionProbability>0.05</dualInfectionProbability>
	<recombinationProbability>0.001</recombinationProbability>
    </recombinantReplicator>
</replicator>
}}}

The parameters are:

 * *<dualInfectionProbability>* : the probability that a child genome should be derived from two parent genomes, using the recombination process, instead of being derived from a single parent genome using clonal replication.
 * *<recombinationProbability>* : the probability per site that a recombination event happens while copying the genome.

== The mutation operator: <mutator> ==

The mutation operator describes the probability that mistakes are made
while creating a new genome.

=== The nucleotide mutation operator: <nucleotideMutator> ===

The nucleotide mutation operator describes the mutation process as a
Poisson process that acts on individual sites. A mutation bias may be
specified either by specifying a bias for transitions versus
transversions, or by specifying the relative rate for all 12 possible
mutations.

An example of a nucleotide mutation operator:

{{{
<mutator>
    <nucleotideMutator>
        <mutationRate>1.0E-4</mutationRate>
        <transitionBias>2.0</transitionBias>
    </nucleotideMutator>
</mutator>
}}}

The parameters are:

* *<mutationRate>*: the probability for a mutation to occur (per site and per generation)
* *<transitionBias>*: a relative preference for transitions versus transversions
* *<rates>*: a white-space separated list of 12 relative rates: A->C A->G A->, CtoA, CtoG, CtoT, GtoA, GtoC, GtoT, TtoA 

== Getting simulation results: <samplingSchedule> ==

== Reusing previously defined objects ==